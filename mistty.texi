\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename mistty.info
@documentencoding UTF-8
@ifinfo
@*Generated by Sphinx.@*
@end ifinfo
@settitle MisTTY
@defindex ge
@paragraphindent 0
@exampleindent 4
@finalout
@dircategory Emacs
@direntry
* MisTTY: (mistty.info). Shell/comint alternative with a fully-functional
                        terminal
@end direntry

@c %**end of header

@copying
@quotation
MisTTY 0.9

Stephane Zermatten

Copyright @copyright{} 2023, Stephane Zermatten
@end quotation

@end copying

@titlepage
@title MisTTY
@insertcopying
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top MisTTY
@insertcopying
@end ifnottex

@c %**start of body
@anchor{index doc}@anchor{0}
`MisTTY' is a major mode for @code{Emacs} 29.1 and up that runs
a shell inside of a buffer, similarly to comint mode. It is built on
top of @code{term.el}. Check out its project page at
@indicateurl{https://github.com/szermatt/mistty}.

@code{M-x mistty} creates a buffer with an interactive shell. See
@ref{1,,Launching} for details.

MisTTY feels very much like comint mode: you can move around freely
and run any Emacs command you want - until you press TAB and end up
with the native completion or notice the shell autosuggestions. With
MisTTY you have access to both Emacs and the shell commands and
editing tools.

Additionally, commands that take over the @ref{2,,entire screen}, such as @code{less} or @code{vi} also
work, temporarily taking over the window, while scrollback remains
available in another buffer.


MisTTY is known to work on Linux and MacOS. It also supports non-shell
command-line programs, such as @code{python}.

The latest version of this documentation is available at
@indicateurl{https://mistty.readthedocs.io/en/latest/}.  Once MisTTY is installed,
this documentation can be accessed from inside Emacs using @code{M-x
info gmistty}

@cartouche
@quotation Note 
If you encounter issues, please take the time to file a bug. See
@ref{3,,Reporting issues} for details.
@end quotation
@end cartouche

@menu
* Comparison with other packages:: 
* Contents:: 
* Index:: 

@end menu

@node Comparison with other packages,Contents,Top,Top
@anchor{index comparison-with-other-packages}@anchor{4}@anchor{index mistty}@anchor{5}
@chapter Comparison with other packages


MisTTY isn’t a terminal emulator, but rather a frontend to an existing
terminal emulator, the built-in @code{term.el}. Its goal is to make
it more convenient to use while inside of Emacs and better integrate
with Emacs itself. In theory, other terminal emulators than
@code{term.el} might be used as engine for MisTTY, such as
@code{vterm} and @code{eat}.

MisTTY has some similarities with @code{coterm}; it offers the
same switch between full-screen and line mode.

@code{Coterm}, @code{ansi-term} and @code{eat} all have a
line mode, just like @code{comint} does, which allows you to edit
a command line as a whole before sending it to the shell. While in
line mode, rendering is done by Emacs and editing commands are Emacs
commands. In constrast, with MisTTY, all rendering is done by the
shell through the terminal. This is why native shell completion and
autosuggestion is available with MisTTY and not in line modes and why
you can freely mix shell commands with Emacs commands while editing
the command line.

@code{ansi-term} and @code{eat} also have a char mode, where
rendering and command execution is handled by the shell, and editing
with Emacs isn’t available. The difference with MisTTY is then that
MisTTY makes Emacs editing commands available when possible.

@code{eat} also has a semi-char mode, which is the closest there
is to MisTTY. In that mode, Emacs movements commands are available.
However, Emacs commands that modify the buffer, aren’t available to
edit the command line. In contrast, MisTTY allows Emacs to navigate to
and edit the whole buffer, then replays changes made to the
command-line.

@node Contents,Index,Comparison with other packages,Top
@anchor{index contents}@anchor{6}
@chapter Contents


@menu
* Usage:: 
* Shells:: 
* Writing Extensions:: 
* FAQ:: 
* Contributing:: 

@end menu

@node Usage,Shells,,Contents
@anchor{usage doc}@anchor{7}@anchor{usage usage}@anchor{8}
@section Usage


@menu
* Installation:: 
* Launching:: 
* Terminal vs. Scrollback: Terminal vs Scrollback. 
* Navigating the scrollback zone:: 
* Fullscreen Mode:: 
* Command History:: 
* Directory tracking and TRAMP:: 

@end menu

@node Installation,Launching,,Usage
@anchor{usage id1}@anchor{9}@anchor{usage installation}@anchor{a}
@subsection Installation


To use MisTTY, first install its package.

@example
(package-vc-install "https://github.com/szermatt/mistty")
@end example

You can then call it, as described in @ref{1,,Launching}.

However, you’ll likely want to configure it and add some key bindings
you use often in shells, for example:

@example
(use-package mistty
  :bind (("C-c s" . mistty)

         ;; bind here the shortcuts you'd like the
         ;; shell to handle instead of Emacs.
         :map mistty-prompt-map

         ;; fish: dir history, more history manipulation
         ("M-<up>" . mistty-send-key)
         ("M-<down>" . mistty-send-key)
         ("M-<left>" . mistty-send-key)
         ("M-<right>" . mistty-send-key)))
@end example

Read on for details on the commands and key bindings configured above.

@node Launching,Terminal vs Scrollback,Installation,Usage
@anchor{usage id2}@anchor{b}@anchor{usage launching}@anchor{1}
@subsection Launching


To create a new interactive shell buffer in MisTTY mode, call
@code{M-x mistty} or @code{M-x mistty-create}. If you use MisTTY
regularly, you’ll want to bind some of these to global shortcuts:

@quotation

@geindex command; mistty-create
@geindex variable; explicit-shell-file-name
@geindex variable; shell-file-name


@itemize -

@item 
@code{M-x mistty-create} launches a new interactive shell in a
MisTTY buffer. The shell that is launched is the one that’s
configured on @code{M-x configure-option explicit-shell-file-name}

If @code{explicit-shell-file-name} is unset, MisTTY falls back to
@code{shell-file-name}, then the environment variables
@geindex ESHELL
@geindex environment variable; ESHELL
@code{ESHELL} and 
@geindex SHELL
@geindex environment variable; SHELL
@code{SHELL}.
@end itemize

@geindex command; mistty-create-other-window


@itemize -

@item 
@code{M-x mistty-create-other-window} does the same, but opens the
buffer in another window.
@end itemize

@geindex command; mistty


@itemize -

@item 
@code{M-x mistty} also creates a new MisTTY buffer the first time
it is called. Afterwards, it’ll to an existing MisTTY buffer or
creating a new one, trying to guess what’s most appropriate.
@end itemize

@geindex command; mistty-other-window


@itemize -

@item 
@code{M-x mistty-other-window} does the same, but opens a buffer
in another window.
@end itemize
@end quotation

@node Terminal vs Scrollback,Navigating the scrollback zone,Launching,Usage
@anchor{usage term-vs-scroll}@anchor{c}@anchor{usage terminal-vs-scrollback}@anchor{d}
@subsection Terminal vs. Scrollback


MisTTY buffers are split into two zones, with different behaviors:

The `scrollback zone', is where you can see commands that have
been executed and their output.

The `terminal zone', marked by a purple line on the left of the
window, is where you can type command and interact with the
terminal. In this zone, @code{TAB} triggers the shell completion, if
available. With some shells, you’ll see autosuggestions as you type.

The scrollback zone behaves as a normal Emacs buffer. You can modify
it as you see fit.

The terminal zone, on the other hand, limits what you can do: When a
shell is attached to the terminal, you can edit the command you’re
about to run, but you can’t edit the prompt itself - or rather, if you
do change the prompt, your change will be undone by the shell.

The terminal zone is where the magic happens: this is where you can
use a mix of Emacs and shell key bindings to edit the command
line. The trickiest part is choosing which key bindings you want Emacs
to handle and which key bindings you want the shell to handle.

By default, Emacs handles everything but a few key bindings are sent
directly to the terminal, bypassing Emacs:


@itemize -

@item 
@code{RET}, to ask the shell to run the command

@item 
@code{TAB}, to ask the shell to run command completion,

@item 
@code{C-a} to ask it to move the cursor to the beginning of the
line, and

@item 
@code{C-e} to ask it to move the cursor to the end of the line.

@item 
@code{C-d} to ask it to either delete the next character or exit the
program.

@item 
@code{M-p} to ask it to go up, or up the command history, sending
@code{C-p} to the terminal.

@item 
@code{M-n} to ask it to go down, or down the command history,
sending @code{C-n} to the terminal.

@item 
@code{M-r} to ask it to do backward history search, sending
@code{C-r} to the terminal.

@item 
@code{M-.} to ask the shell to insert the last history argument.
@end itemize

In addition, @code{C-c C-c} sends the TERM signal to the terminal.

The program attached to the terminal decides what the actual effect of
these shortcuts is. Most shells and command-line editing tools
supports the shortcuts above by default, but they might not work
everywhere as expected.

@cartouche
@quotation Warning 
MisTTY will not work if you’ve configured your shell to turn on
`VI mode' by default. Please `turn it off' before trying out
MisTTY, for details on how to turn off VI mode only of MisTTY
buffers and leave it on otherwise, check out the instructions in
@ref{e,,Shells} for details. VI mode must be turned off even if you
just end up controlling it with VI commands using Evil.
@end quotation
@end cartouche

To get the most out of MisTTY, it’s worth it to take the time to
configure it forward the shell key bindings that you actually use to
the terminal and keep everything else behaving as usual for your Emacs
configuration.

@geindex map; mistty-prompt-map
@geindex map; mistty-mode-map

To bind keys only in the terminal zone, bind them to
:code`mistty-prompt-map`. To bind keys in both zones, bind them to
@code{mistty-mode-map}. See examples below.

The following commands are useful to send key sequences to the current
shell or program controlling the terminal:

@quotation

@geindex command; mistty-send-key


@itemize -

@item 
The command @code{mistty-send-key}, called interactively,
forwards the key it was called from. It is meant to be bound to
the shell key bindings you want to work in the terminal zone map,
@code{mistty-prompt-map}.

For example, searching in the shell command history is usually
bound to @code{C-r}, MisTTY binds that to @code{M-r}, like comint
does, but if you’d like it to be accessible using the original key
binding, you can do:

@example
(keymap-set mistty-prompt-map "C-r" #'mistty-send-key)
@end example

If you’d prefer to have the key available in both the scrollback
and terminal zones, bind it @code{mistty-mode-map} instead.

You can also pass arbitrary keys to @code{mistty-send-key}, for
example:

@example
(defun my-mistty-M-s (n)
  (interactive "p")
  (mistty-send-key n (kbd "M-s")))
(keymap-set mistty-prompt-map "C-c a" #'my-mistty-M-s)
@end example
@end itemize

@geindex command; mistty-send-last-key


@itemize -

@item 
The command @code{mistty-send-last-key} forwards the last key
combination of a sequence it was called from to the terminal. For
example, @code{C-c C-c} is bound to @code{mistty-send-last-key}
so that the terminal eventually just gets @code{C-c}.
@end itemize
@end quotation

To just try things out, or for shell shortcuts you don’t use
regularly, you can use the @code{C-q} prefix to bypass Emacs key
bindings and send keys directly to the terminal. For example,
@code{C-q <right>} sends a right arrow key press to the terminal
instead of moving the cursor.

If that’s not enough,

@quotation

@geindex command; mistty-send-key-sequence


@itemize -

@item 
@code{C-c C-q}, @code{M-x mistty-send-key-sequence} sends all keys
you press to the terminal until you press @code{C-g}.
@end itemize
@end quotation

@node Navigating the scrollback zone,Fullscreen Mode,Terminal vs Scrollback,Usage
@anchor{usage navigating-the-scrollback-zone}@anchor{f}@anchor{usage navigation}@anchor{10}
@subsection Navigating the scrollback zone


@quotation

@geindex command; mistty-end-of-line-goto-cursor


@itemize -

@item 
@code{C-e C-e} moves the point back inside the prompt. This is
handled by the interactive function
@code{mistty-end-of-line-or-goto-cursor}
@end itemize

@geindex command; mistty-goto-cursor


@itemize -

@item 
@code{M-x mistty-goto-cursor} also moves the point back inside the
prompt. You can bind it to a custom shortcut if you don’t like
overloading C-e.
@end itemize

@geindex command; mistty-previous-output


@itemize -

@item 
@code{C-c C-p} or @code{M-x mistty-goto-previous-output} goes to
the beginning of the previous command output. This is useful to if
the buffer has scrolled too far and you want to see it from the
beginning.
@end itemize

@geindex command; mistty-next-output


@itemize -

@item 
@code{C-c C-n} or @code{M-x mistty-goto-next-output} does the
reverse, that is, it goes to the next command output.
@end itemize

@geindex command; mistty-create-buffer-with-output


@itemize -

@item 
@code{C-c C-r} or @code{M-x mistty-create-buffer-with-output} creates
a new buffer containing the last command output.
@end itemize

@geindex command; mistty-goto-previous-input


@itemize -

@item 
@code{M-x mistty-goto-previous-input} goes to the beginning of the
previous command input, that is, the previous prompt. While this
is a way of going back the command you’ve previously input, it’s
best to use the shell native command history, as discussed in
@ref{11,,Command History}.
@end itemize

@geindex command; mistty-goto-next-input


@itemize -

@item 
@code{M-x mistty-goto-next-input} goes to the next command input.
@end itemize
@end quotation

@node Fullscreen Mode,Command History,Navigating the scrollback zone,Usage
@anchor{usage fullscreen}@anchor{2}@anchor{usage fullscreen-mode}@anchor{12}
@subsection Fullscreen Mode


MisTTY detects when a program such as @code{less} or @code{vi}
asks to run full screen and splits the MisTTY buffers into:


@itemize -

@item 
a terminal buffer, which shows the program output and lets you
interact with it. This is a term-mode buffer.

@item 
a scrollback buffer, which shows the previous command lines and
their output.
@end itemize

@geindex command; mistty-toggle-buffers

@code{C-c C-j} or @code{M-x mistty-toggle-buffers} switches between
these two.

When the program exits, the two buffers are again merged. Note that
the output of the full screen app isn’t available in the scrollback.

@node Command History,Directory tracking and TRAMP,Fullscreen Mode,Usage
@anchor{usage command-history}@anchor{13}@anchor{usage history}@anchor{11}
@subsection Command History


MisTTY doesn’t track command history. It relies instead on being able
to access the history of the different interactive command-line tools.

The command history available in most shells and command-line editing tools is
available in MisTTY using the following shortcuts:


@itemize -

@item 
@code{M-p} moves up command history

@item 
@code{M-n} moves down command history

@item 
@code{M-r} triggers a backward search in command history

@item 
@code{M-.} insert the last argument from command history.
@end itemize

To get the same key bindings you’d get in a normal terminal, you can
bind @code{C-p}, @code{C-n}, or @code{C-r} to @code{mistty-send-key}
in the terminal zone of the MisTTY buffer. For example:

@example
(keymap-set mistty-prompt-map "C-p" #'mistty-send-key)
(keymap-set mistty-prompt-map "C-n" #'mistty-send-key)
(keymap-set mistty-prompt-map "C-r" #'mistty-send-key)
@end example

@node Directory tracking and TRAMP,,Command History,Usage
@anchor{usage directory-tracking-and-tramp}@anchor{14}@anchor{usage dirtrack}@anchor{15}
@subsection Directory tracking and TRAMP


In order for Emacs to know your shell’s current directory, the shell
has to tell MisTTY about it. This is usually done from the prompt.

@code{Bash} does it by default, for local shells, when it detects
a terminal of type @code{TERM=eterm-color} run from inside Emacs.

Other shells need to be configured to do the same. For more details,
see @ref{e,,Shells}.

@geindex variable; mistty-allow-tramp-path

If you have configured TRAMP and know that the hosts you ssh into are
accessible with the default TRAMP method, you might consider allowing
MisTTY to report remote paths on @code{M-x configure-option
mistty-allow-tramp-paths}

@node Shells,Writing Extensions,Usage,Contents
@anchor{shells doc}@anchor{16}@anchor{shells id1}@anchor{17}@anchor{shells shells}@anchor{e}
@section Shells


@menu
* Bash:: 
* Fish:: 
* Zsh:: 

@end menu

@node Bash,Fish,,Shells
@anchor{shells bash}@anchor{18}@anchor{shells id2}@anchor{19}
@subsection Bash


A recent version of Bash is preferable. Bash 5.1 and later work best,
as bracketed paste mode is on by default in that version.

Older versions of Bash work, but with limitations, and it might
behaves unexpectedly when yanking text containing special characters.

To use Bash between 4.4 and 5.0 without these limitations, add the
following to your @code{.inputrc}:

@example
set enable-bracketed-paste on
@end example

@menu
* Multi-line prompts:: 
* Directory tracking:: 
* VI mode:: 

@end menu

@node Multi-line prompts,Directory tracking,,Bash
@anchor{shells multi-line-prompts}@anchor{1a}
@subsubsection Multi-line prompts


When you press @code{RET} on an incomplete command, @code{bash}
has the annoying habit of starting a secondary prompt which doesn’t
let you go back to the previous line with the default keybindings.

To work around that, type @code{S-<return>} instead of @code{RET}
while on the terminal zone of a MisTTY buffer. This sends a newline
without running the command. You’ll then end up with one multi-line
prompt that you can edit normally. This requires Bash 5.1 or an
earlier version with bracketed paste mode turned on.

You’ll get the same effect if you yank a multi-line command while in a
prompt or go up the command history to a previous multi-line command.

@node Directory tracking,VI mode,Multi-line prompts,Bash
@anchor{shells directory-tracking}@anchor{1b}
@subsubsection Directory tracking


Recent versions of @code{bash} already send the current directory
when they detects that it’s called from Emacs with
@code{TERM=eterm-color}, so as long as you don’t want TRAMP remote
paths, you don’t have to do anything.

If you do want to use TRAMP remote paths, extend your prompt to send
out an OSC7 sequence to have @code{bash} send the current
directory and hostname to MisTTY.

To do that, you might add the following to @code{~/.bashrc}:

@example
if [ "$TERM" = "eterm-color" ]; then
  PS1='\e]7;file://$HOSTNAME$PWD\e\\\\'$PS1
fi
@end example

Such sequence are either ignored or understood by most terminals, so
you don’t absolutely need to check TERM.

@node VI mode,,Directory tracking,Bash
@anchor{shells vi-mode}@anchor{1c}
@subsubsection VI mode


To communicate with @code{bash}, MisTTY requires the shell to be
in its default editing mode, that is, the emacs mode. `Please make
sure you haven’t put readline or bash in vi mode before trying out
MisTTY.'

To turn on vi mode in readline everywhere but MisTTY, you can add
something like the following into @code{~/.inputrc}:

@example
$if term=eterm
  set editing-mode emacs
$else
  set editing-mode vi
$endif
@end example

Or, in bash @code{~/.bashrc}:

@example
if [ "$TERM" != "eterm-color" ]; then
  set -o vi
fi
@end example

@node Fish,Zsh,Bash,Shells
@anchor{shells fish}@anchor{1d}@anchor{shells id3}@anchor{1e}
@subsection Fish


A recent version of Fish is preferable. MisTTY relies on bracketed
paste mode, on by default, so it should not be turned off.

@menu
* Autosuggestions:: 
* Command History: Command History<2>. 
* Directory tracking: Directory tracking<2>. 
* Multi-line prompts: Multi-line prompts<2>. 
* VI mode: VI mode<2>. 

@end menu

@node Autosuggestions,Command History<2>,,Fish
@anchor{shells autosuggestions}@anchor{1f}
@subsubsection Autosuggestions


@code{fish} autosuggestions work normally in MisTTY. However, the
usual way of accepting an autosuggestion, pressing the right arrow
key, is very inconvenient as this is bound to an Emacs point movement.

The recommended way of accepting an autosuggestion in MisTTY is to
type @code{C-e}. This works in normal terminals as well.

@node Command History<2>,Directory tracking<2>,Autosuggestions,Fish
@anchor{shells command-history}@anchor{20}
@subsubsection Command History


To make full use of @code{fish} command history, you’ll want to
forward some additional shortcuts to fish:

@example
(keymap-set mistty-prompt-map "M-<up>" #'mistty-send-key)
(keymap-set mistty-prompt-map "M-<down>" #'mistty-send-key)
(keymap-set mistty-prompt-map "M-<left>" #'mistty-send-key)
(keymap-set mistty-prompt-map "M-<right>" #'mistty-send-key)
@end example

This can also be done by calling @code{use-package} as shown in
@ref{a,,Installation}.

When in reverse history search mode, @code{fish} enters a mode
that lets you select an option using the arrow keys. To send
up/down/left/right directly to @code{fish}, you can:


@itemize -

@item 
use @code{M-p} to go up and @code{M-n} to go down, or, if you prefer

@item 
use @code{C-q <up>} @code{C-q <down>} @code{C-q <left>} @code{C-q <right>}, or even

@item 
@code{C-c C-q} to temporarily send all send key presses to @code{fish}
@end itemize

@node Directory tracking<2>,Multi-line prompts<2>,Command History<2>,Fish
@anchor{shells id4}@anchor{21}
@subsubsection Directory tracking


Extend your prompt to send out an OSC7 sequence to have
@code{fish} send the current directory and hostname to MisTTY. To
do that, you might add the following to
@code{~/.local/config/fish/config.fish}:

@example
if [ "$TERM" = "eterm-color" ]
  function osc7_send_pwd --on-event fish_prompt
    printf "\e]7;file://%s%s\e\\\\" (hostname) "$PWD"
  end
end
@end example

such sequence are either ignored or understood by most terminals. You
might already have it set up.

@node Multi-line prompts<2>,VI mode<2>,Directory tracking<2>,Fish
@anchor{shells id5}@anchor{22}
@subsubsection Multi-line prompts


@code{fish} automatically detects when a command is incomplete
when you type @code{RET} and launches a multi-line prompt, which
MisTTY knows to navigate.

@geindex variable; mistty-skip-empty-spaces

The cursor jumps over indent space while on such a prompt, just like
in a normal terminal. @code{M-x customize-option
mistty-skip-empty-spaces} allows you to turn that on or off in a
MisTTY buffer.

@node VI mode<2>,,Multi-line prompts<2>,Fish
@anchor{shells id6}@anchor{23}
@subsubsection VI mode


To communicate with @code{fish}, MisTTY requires the shell to be
in its default editing mode, that is, the emacs mode. `Please make
sure you haven’t put readline or bash in vi mode before trying out
MisTTY.'

To turn on vi mode in readline everywhere but in MisTTY, you can add
something like the following in @code{~/.zshrc}:

@example
if [ "$TERM" != "eterm-color" ]
  fish_vi_key_bindings
end
@end example

@node Zsh,,Fish,Shells
@anchor{shells id7}@anchor{24}@anchor{shells zsh}@anchor{25}
@subsection Zsh


A recent version of Zsh is preferable.

Zsh supports bracketed paste, which MisTTY relies on, since version
5.1. Older versions will work, but with limitations, and you might get
unexpected results if you yank text containing special characters.

@menu
* Autosuggestions: Autosuggestions<2>. 
* Directory tracking: Directory tracking<3>. 
* Multi-line prompts: Multi-line prompts<3>. 
* VI mode: VI mode<3>. 

@end menu

@node Autosuggestions<2>,Directory tracking<3>,,Zsh
@anchor{shells id8}@anchor{26}
@subsubsection Autosuggestions


Fish-like @code{zsh} autosuggestions work normally in MisTTY, if
you’ve turned these on. However, the usual way of accepting an
autosuggestion, pressing the right arrow key, is very inconvenient as
this is normally bound to an Emacs point movement.

The recommended way of accepting an autosuggestion in MisTTY is to
type @code{C-e}. This works in normal terminals as well.

@node Directory tracking<3>,Multi-line prompts<3>,Autosuggestions<2>,Zsh
@anchor{shells id9}@anchor{27}
@subsubsection Directory tracking


Extend your prompt to send out an OSC7 sequence to have
@code{zsh} send the current directory and hostname to MisTTY. To
do that, you might add the following to @code{~/.zshrc}:

@example
if [ "$TERM" != "eterm-color" ]; then
    PS1='\e]7;file://$HOSTNAME$PWD\e\\\\'$PS1
fi
@end example

such sequence are either ignored or understood by most terminals.

@node Multi-line prompts<3>,VI mode<3>,Directory tracking<3>,Zsh
@anchor{shells id10}@anchor{28}
@subsubsection Multi-line prompts


When you press @code{RET} on an incomplete command, @code{zsh}
has the annoying habit of starting a secondary prompt. MisTTY doesn’t
know how to go back to the previous prompt from such a prompt.

To work around that, type @code{S-<return>} instead of @code{RET}
while on the terminal zone of a MisTTY buffer. This sends a newline
without running the command. You’ll then end up with one multi-line
prompt that you can edit normally. This requires a version of Zsh that
supports bracketed paste mode, 5.1 or later.

You’ll get the same effect if you yank a multi-line command while in a
prompt or go up the command history to a previous multi-line command.

@node VI mode<3>,,Multi-line prompts<3>,Zsh
@anchor{shells id11}@anchor{29}
@subsubsection VI mode


To communicate with @code{zsh}, MisTTY requires the shell to be in
its default editing mode, that is, the emacs mode. `Please make sure
you haven’t put readline or bash in vi mode before trying out
MisTTY.'

To turn on vi mode in readline everywhere but in MisTTY, you can add
something like the following in @code{~/.zshrc}:

@example
if [ "$TERM" != "eterm-color" ]; then
  bindkey -v
fi
@end example

@node Writing Extensions,FAQ,Shells,Contents
@anchor{extensions doc}@anchor{2a}@anchor{extensions writing-extensions}@anchor{2b}
@section Writing Extensions


@menu
* OSC Sequences:: 
* Writing Your Own Commands:: 
* Terminal Keymap:: 

@end menu

@node OSC Sequences,Writing Your Own Commands,,Writing Extensions
@anchor{extensions osc}@anchor{2c}@anchor{extensions osc-sequences}@anchor{2d}
@subsection OSC Sequences


OSC are “operating system command” control sequences. MisTTY supports
some of these sequences and ignores the others.

By default, the supported sequences are OSC 2 (set window title), 7
(directory tracking, already mentioned in @ref{15,,Directory tracking and TRAMP}) and 8
(hyperlinks), thanks to @code{ansi-osc.el}.

@geindex variable; mistty-osc-handlers

To add more, register handlers to @code{mistty-osc-handlers}. The
format is the same as the handlers supported for
@code{ansi-osc-handlers} and can usually be used interchangeably.

When working on OSC handlers for MisTTY, it’s important to keep the
following in mind: MisTTY separate buffers for the terminal (a
@code{term-mode} buffer) and for MisTTY itself. The OSC handlers run
in the term-mode buffer.

@geindex variable; mistty-variables-to-copy

One consequence of this is that if you set a buffer-local variable in
a handler, it won’t be available in the MisTTY buffer unless you
register it to @code{M-x configure-option mistty-variables-to-copy}

MisTTY provides helpers for writing OSC handlers that set text
properties:

@geindex command; mistty-register-text-properties
@geindex command; mistty-unregister-text-properties


@itemize -

@item 
The function @code{mistty-register-text-properties} registers a set
of text properties to set on any text written to the terminal until
@code{mistty-unregister-text-properties} is called with the
same argument.
@end itemize

@node Writing Your Own Commands,Terminal Keymap,OSC Sequences,Writing Extensions
@anchor{extensions custom-commands}@anchor{2e}@anchor{extensions writing-your-own-commands}@anchor{2f}
@subsection Writing Your Own Commands


You might find the following functions useful if you’d like to write
commands that extend MisTTY’s behavior:

@geindex function; mistty-send-string


@itemize -

@item 
@code{mistty-send-string} sends a string to the terminal,
unmodified. The string that is sent appear only after the function
return - and it might not ever appear at all depending on the
application attached to the terminal. This is used to implement
@code{mistty-sudo} for example.
@end itemize

@geindex function; mistty-on-prompt-p


@itemize -

@item 
@code{mistty-on-prompt-p} returns non-nil if the given position is
inside of a prompt MisTTY is aware of. This is useful for writing
commands that behave differently on a prompt than on program output,
even while inside of the terminal zone. It is used to implement
@code{mistty-beginning-of-line} for example.
@end itemize

@geindex function; mistty-maybe-realize-possible-prompt


@itemize -

@item 
@code{mistty-maybe-realize-possible-prompt} might be useful to call
in your commands to tell MisTTY that there’s likely a prompt at the
current pointer position.
@end itemize

@geindex function; mistty-before-position


@itemize -

@item 
@code{mistty-before-position} not only check whether there’s a
prompt at the position, but also attempt to move the terminal cursor
to that position.
@end itemize

@node Terminal Keymap,,Writing Your Own Commands,Writing Extensions
@anchor{extensions term-keymap}@anchor{30}@anchor{extensions terminal-keymap}@anchor{31}
@subsection Terminal Keymap


@geindex function; mistty-translate-key
@geindex map; mistty-term-key-map

To forward a key binding to the application attached to the terminal
@cite{mistty-send-key} first needs to convert that key binding to something
applications will understand. The translation is done by
@code{mistty-translate-key}.

@quotation

The function @code{mistty-translate-key} takes an Emacs key
binding, as returned by @cite{kbd} and returns a string containing the
sequence of characters that correspond to that key to send to the
application tied to the terminal.
@end quotation

The default terminal keymap used by MisTTY mimics @code{xterm} key
bindings. You might extend it or change it by changing the map
@code{mistty-term-key-map}.

For example, you can change the string that correspond to the first
function keys from their default (”\eOP” - “\eOS”) as follows:

@example
(define-key mistty-term-key-map (kbd "<f1>") "\e[11~")
(define-key mistty-term-key-map (kbd "<f2>") "\e[12~")
(define-key mistty-term-key-map (kbd "<f3>") "\e[13~")
(define-key mistty-term-key-map (kbd "<f4>") "\e[14~")
@end example

@geindex function; mistty-reverse-input-decode-map

@code{M-x mistty-reverse-input-decode-map} generates alternative
values for @code{mistty-term-key-map} for you if you’d like mimic
another set of key bindings than xterm, for example, to generate a
keymap that simulates rxvt, you might do:

@example
(load-library "term/rxvt.el")
(mistty-reverse-input-decode-map rxvt-function-map)
@end example

@code{mistty-reverse-input-decode-map.el} is not included into the
distribution; it’s only available on github@footnote{https://github.com/szermatt/mistty/tree/master/extras}.

@node FAQ,Contributing,Writing Extensions,Contents
@anchor{faq doc}@anchor{32}@anchor{faq faq}@anchor{33}
@section FAQ


`What are all those OCOCOCO or ODODODO that appear on the screen?'

@quotation

These are the terminal sequences that MisTTY sends to a program
to move the cursor left or right. If you see these printed on the
terminal, it means that the program that’s currently controlling
the terminal doesn’t support these.

In such situation, you can:


@itemize -

@item 
Only type self-inserting characters and @code{DEL}.

@item 
Press @code{C-c C-q} or @code{M-x mistty-send-key-sequence} to
send what you type directly to the terminal until you turn it
off with @code{C-g}.

@item 
Write a regexp that identifies the situation and add it to
@code{M-x customize-option mistty-forbid-edit-regexps}.
@end itemize

See the section @ref{c,,Terminal vs. Scrollback} for more details.
@end quotation

`Why is the cursor jumping around when I move it?'

@quotation

MisTTY jumps over spaces which just “aren’t there”, such as the
spaces between the command and the right prompt, spaces added by
@code{fish} for indentation in multi-line prompts.

If it doesn’t work with your shell or setup, or if you find it
confusing, type @code{M-x customize-option
mistty-skip-empty-spaces} to turn it off.
@end quotation

`What’s with the purple line?'

@quotation

This line indicates the region of the buffer that works as a
terminal, meaning that it is not fully editable and that some
shortcuts, such as @code{TAB} are sent directly to the program
controlling the terminal.

This is covered in depth in the section @ref{c,,Terminal vs. Scrollback}.

If you just don’t want to see that line, turn it off with
@code{M-x customize-option mistty-fring-enabled}
@end quotation

@node Contributing,,FAQ,Contents
@anchor{contrib doc}@anchor{34}@anchor{contrib contributing}@anchor{35}
@section Contributing


@menu
* Reporting issues:: 
* Suggesting features:: 
* Asking questions:: 
* Code contributions:: 
* Documentation contributions:: 

@end menu

@node Reporting issues,Suggesting features,,Contributing
@anchor{contrib reporting}@anchor{3}@anchor{contrib reporting-issues}@anchor{36}
@subsection Reporting issues


At this time, the most useful thing you can do to help is and useful
bug reports to the Issue Tracker@footnote{https://github.com/szermatt/mistty/issues}

In your report, please discuss what you wanted to happen as well as
what happened. Also, please include enough information to reproduce
the issue. Such as:


@itemize -

@item 
the name and version of the program you were running - usually a shell

@item 
the version of Emacs you’re running, taken, for example, from @code{M-x about-emacs}

@item 
whether you’re running Emacs in a window environment or a terminal
@end itemize

@geindex command; mistty-start-log
@geindex command; mistty-stop-log

If you can reproduce reliably, please include the content of the
buffer @code{*mistty-log*} into your report, as follows:


@itemize -

@item 
Enable logging with @code{M-x mistty-start-log}

@item 
Reproduce the issue

@item 
Go to the buffer @code{*mistty-log*}

@item 
call @code{M-x mistty-stop-log}

@item 
copy the buffer content and paste it into the issue. The log
includes everything that you write to the terminal and everything
that you get back from the terminal. Please make sure you’re not
including any private information, such as password - remove them if
necessary…
@end itemize

If you cannot reproduce reliably,


@itemize -

@item 
go to @code{M-x customize-option mistty-backlog-size} to set the
backlog size to a large value, such as 50

@item 
use MisTTY normally, until the issue comes back

@item 
once it has happened again, immediately call @code{M-x
mistty-start-log}. The log will then contain entries for events that
happened just `before' you called the command.

@item 
call @code{M-x mistty-stop-log}

@item 
copy the content of the @code{*mistty-log*} buffer, strip out
anything private, and include it into the issue.
@end itemize

@node Suggesting features,Asking questions,Reporting issues,Contributing
@anchor{contrib issue-tracker}@anchor{37}@anchor{contrib suggesting-features}@anchor{38}
@subsection Suggesting features


Please add feature suggestions to the Issue Tracker@footnote{https://github.com/szermatt/mistty/issues}.

@node Asking questions,Code contributions,Suggesting features,Contributing
@anchor{contrib asking-questions}@anchor{39}
@subsection Asking questions


Open an issue on the Issue Tracker@footnote{https://github.com/szermatt/mistty/issues} with your question.

@node Code contributions,Documentation contributions,Asking questions,Contributing
@anchor{contrib code-contributions}@anchor{3a}
@subsection Code contributions


To contribute code to the project, open a Pull Request@footnote{https://github.com/szermatt/emacs-bash-completion/pulls}.

Before you do that, please make sure the any new features is covered
by tests and that the tests pass.

To run the tests, install and setup eldev@footnote{https://github.com/emacs-eldev/eldev} then run @code{eldev
test}.

Tests can also be run from inside of Emacs, using @cite{M-x ert-run-tests-interactively} but when you do so, be aware that there
might be unexpected interaction with your Emacs configurations. The
tests passing reliably when run using @code{eldev test} is what
matters.

@node Documentation contributions,,Code contributions,Contributing
@anchor{contrib documentation-contributions}@anchor{3b}@anchor{contrib eldev}@anchor{3c}
@subsection Documentation contributions


You don’t need to be a developer to contribute! Contribution to the
documentation or code comments are very welcome. Please open a Pull Request@footnote{https://github.com/szermatt/emacs-bash-completion/pulls} with your proposed modifications.

The documentation is written in reStructuredText. You’ll need to
install Sphinx@footnote{https://www.sphinx-doc.org} to build it:

@example
pip install sphinx sphinx-rtd-theme
@end example

Then run @code{eldev html} to build the documentation.

@node Index,,Contents,Top
@unnumbered Index


@printindex ge


@c %**end of body
@bye
