;;; mistty.el --- Queue of terminal actions for mistty.el. -*- lexical-binding: t -*-

;; This program is free software: you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 3 of the
;; License, or (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see
;; `http://www.gnu.org/licenses/'.

;;; Code:

(eval-when-compile
  (require 'cl-lib))

;;; Commentary:
;;
;; This file defines the struct `mistty--queue' to be used in mistty.el.
;;
;; `mistty--queue' sends strings to the terminal process in sequence,
;; using a generator to adapt the next string to the current state of
;; the process.

(require 'generator)

(require 'mistty-log)
(require 'mistty-util)

;; A queue of strings to send to the terminal process.
;;
;; The queue contains a generator, which yields the strings to send to
;; the terminal.
(cl-defstruct (mistty--queue
               (:constructor mistty--make-queue (proc))
               (:conc-name mistty--queue-)
               (:copier nil))
  ;; The process the queue is communicating with.
  proc

  ;; A generator that yields strings to send to the terminal or nil.
  iter

  ;; Timer used by mistty--dequeue-with-timer.
  timer

  ;; Timer called if the process doesn't not answer after a certain
  ;; time.
  timeout
)

(defsubst mistty--queue-empty-p (queue)
  "Return t if QUEUE generator hasn't finished yet."
  (not (mistty--queue-iter queue)))

(defun mistty--send-string (proc str)
  "Send STR to PROC, if it is still live."
  (when (and (mistty--nonempty-str-p str)
             (process-live-p proc))
    (mistty-log "SEND[%s]" str)
    (process-send-string proc str)))

(defun mistty--enqueue-str (queue str &optional fire-and-forget)
  "Enqueue sending STR to the terminal into QUEUE.

Does nothing is STR is nil or empty."
  (when (mistty--nonempty-str-p str)
    (mistty--enqueue
     queue
     (mistty--iter-single
      (if fire-and-forget
          (list 'fire-and-forget str)
        str)))))

(defun mistty--enqueue (queue gen)
  "Add GEN to QUEUE.

The given generator should yield strings to send to the process.
`iter-yield' calls return once some response has been received
from the process or after too long has passed without response.
In the latter case, `iter-yield' returns \\='timeout.

If the queue is empty, this function also kicks things off by
sending the first string generated by GEN to the process.

If the queue is not empty, GEN is appended to the current
generator, to be executed afterwards.

Does nothing if GEN is nil."
  (cl-assert (mistty--queue-p queue))
  (when gen
    (if (mistty--queue-empty-p queue)
        (progn ; This is the first generator; kick things off.
          (setf (mistty--queue-iter queue) gen)
          (mistty--dequeue queue))
      (setf (mistty--queue-iter queue)
            (mistty--iter-chain (mistty--queue-iter queue) gen)))))

(defun mistty--dequeue (queue &optional value)
  "Send the next string from QUEUE to the terminal.

If VALUE is set, send that value to the first call to `iter-next'."
  (cl-assert (mistty--queue-p queue))
  (mistty--cancel-timeout queue)
  (unless (mistty--queue-empty-p queue)
    (condition-case nil
        (let ((proc (mistty--queue-proc queue))
              (stop nil)
              (calling-buffer (current-buffer)))
          (save-excursion
            (while (not stop)
              (let ((next-value (iter-next (mistty--queue-iter queue) value)))
                (set-buffer calling-buffer)
                (setq value nil)
                (cond
                 ;; Fire-and-forget; no need to wait for a response
                 ((and (listp next-value)
                       (eq (nth 0 next-value) 'fire-and-forget)
                       (mistty--nonempty-str-p (nth 1 next-value)))
                  (mistty--send-string proc (nth 1 next-value)))

                 ;; Normal sequences
                 ((mistty--nonempty-str-p next-value)
                  (setf (mistty--queue-timeout queue)
                        (run-with-timer
                         0.5 nil #'mistty--timeout-handler
                         (current-buffer) queue))
                  (mistty--send-string proc next-value)
                  (setq stop t)))))))
      (iter-end-of-sequence
       (setf (mistty--queue-iter queue) nil)))))

(defun mistty--dequeue-with-timer (queue)
  "Call `mistty--dequeue' on QUEUE on a timer.

The idea is to accumulate updates that arrive at the same time
from the process, waiting for it to pause.

This function restarts the timer if a dequeue is already
scheduled."
  (cl-assert (mistty--queue-p queue))
  (mistty--cancel-timeout queue)
  (mistty--cancel-timer queue)
  (unless (mistty--queue-empty-p queue)
    (setf (mistty--queue-timer queue)
          (run-with-timer
           0.1 nil #'mistty--queue-timer-handler
           (current-buffer) queue))))

(defun mistty--cancel-queue (queue)
  "Clear QUEUE and cancel all pending actions.

The queue remains usable, but empty."
  (when (mistty--queue-iter queue)
    (iter-close (mistty--queue-iter queue))
    (setf (mistty--queue-iter queue) nil))
  (mistty--cancel-timeout queue)
  (mistty--cancel-timer queue))

(defun mistty--cancel-timeout (queue)
  "Cancel the timeout timer in QUEUE."
  (cl-assert (mistty--queue-p queue))
  (when (timerp (mistty--queue-timeout queue))
    (cancel-timer (mistty--queue-timeout queue))
    (setf (mistty--queue-timeout queue) nil)))

(defun mistty--cancel-timer (queue)
  "Cancel the timer in QUEUE."
  (cl-assert (mistty--queue-p queue))
  (when (timerp (mistty--queue-timer queue))
    (cancel-timer (mistty--queue-timer queue))
    (setf (mistty--queue-timer queue) nil)))

(defun mistty--timeout-handler (buf queue)
  "Handle timeout in QUEUE.

The code is executed inside BUF.

This function is meant to be use as timer handler."
  (cl-assert (mistty--queue-p queue))
  (mistty--with-live-buffer buf
    (let ((proc (mistty--queue-proc queue)))
      (when (and (mistty--queue-timeout queue)
                 ;; last chance, in case some scheduling kerfuffle meant
                 ;; process output ended up buffered.
                 (not (and (process-live-p proc)
                           (accept-process-output proc 0 nil t))))
        (setf (mistty--queue-timeout queue) nil)
        (mistty-log "TIMEOUT")
        (mistty--dequeue queue 'timeout)))))

(defun mistty--queue-timer-handler (buf queue)
  "Idle timer callback that calls `mistty--dequeue' on QUEUE.

The code is executed inside BUF.

This function is meant to be use as timer handler."
  (cl-assert (mistty--queue-p queue))
  (mistty--with-live-buffer buf
    (setf (mistty--queue-timer queue) nil)
    (mistty--dequeue queue)))

(iter-defun mistty--iter-single (elt)
  "Build a generator that returns ELT and ends."
  (iter-yield elt))

(defmacro mistty--call-iter (iter)
  "Call ITER from another generator."
  `(let ((iter ,iter))
     (unwind-protect
         (iter-do (value iter)
           (iter-yield value))
       (iter-close iter))))

(iter-defun mistty--iter-chain (iter1 iter2)
  "Build a generator that first calls ITER1, then ITER2."
  (mistty--call-iter iter1)
  (mistty--call-iter iter2))

(provide 'mistty-queue)

;;; mistty-queue.el ends here
