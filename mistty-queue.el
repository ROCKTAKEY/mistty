;;; mistty.el --- Queue of terminal actions for mistty.el. -*- lexical-binding: t -*-

(require 'mistty-log)

(defvar-local mistty--queue nil
  "A generator of strings to send to the terminal.

See `mistty--enqueue' for details.")

(defvar-local mistty--queue-timeout-timer nil
  "A timer called when the process takes too long to answer.

If no response is received from the process after that long,
consider that nothing will ever come and continue. Any pending
`iter-yield' calls returns \\='timeout.")

(defvar-local mistty--dequeue-timer nil
  "Idle timer that calls `mistty--dequeue'.

This is scheduled to run after the process filter has updated the
term buffer.")

(defun mistty--send-string (proc str)
  (when (and str (length> str 0) (process-live-p proc))
    (mistty-log "SEND[%s]" str)
    (process-send-string proc str)))

(defun mistty--dequeue (proc &optional value)
  "Send the next string from the queue to the terminal.

If VALUE is set, send that value to the first call to `iter-next'."
  (mistty--cancel-dequeue-timeout)
  (mistty-log "dequeue %s" value)
  (condition-case nil
      (let (seq)
        (setq seq (iter-next mistty--queue value))
        (while (or (null seq) (length= seq 0))
          (setq seq (iter-next mistty--queue)))
        (setq mistty--queue-timeout-timer
              (run-with-timer
               0.5 nil #'mistty--dequeue-timeout-handler
               (current-buffer) proc))
        (mistty--send-string proc seq))
    (iter-end-of-sequence
     (setq mistty--queue nil))))

(defun mistty--dequeue-with-timer (proc)
  "Call `mistty--dequeue' on a timer.

Restart the timer if a dequeue is already scheduled. The idea is
to accumulate updates that arrive at the same time from the
process, waiting for it to pause."
  (mistty--cancel-dequeue-timeout)
  (when (timerp mistty--dequeue-timer)
    (cancel-timer mistty--dequeue-timer)
    (setq mistty--dequeue-timer nil))
  (when mistty--queue
    (setq mistty--dequeue-timer
          (run-with-timer
           0.1 nil #'mistty--dequeue-timer-handler
           (current-buffer) proc))))

(defun mistty--cancel-dequeue-timeout ()
  (when (timerp mistty--queue-timeout-timer)
    (cancel-timer mistty--queue-timeout-timer)
    (setq mistty--queue-timeout-timer nil)))

(defun mistty--dequeue-timeout-handler (buf proc)
  (mistty--with-live-buffer buf
    (when (and mistty--queue-timeout-timer
               ;; last chance, in case some scheduling kerfuffle meant
               ;; process output ended up buffered.
               (not (and (process-live-p proc)
                         (accept-process-output proc 0 nil t))))
      (setq mistty--queue-timeout-timer nil)
      (mistty-log "TIMEOUT")
      (mistty--dequeue proc 'timeout))))

(defun mistty--dequeue-timer-handler (buf proc)
  "Idle timer callback that calls `mistty--dequeue'."
  (mistty--with-live-buffer buf
    (setq mistty--dequeue-timer nil)
    (mistty--dequeue proc)))


(defun mistty--enqueue-str (proc str)
  "Enqueue sending STR to the terminal.

Does nothing is STR is nil or empty."
  (when (and str (length> str 0))
    (mistty--enqueue proc (mistty--iter-single str))))

(defun mistty--enqueue (proc gen)
  "Add GEN to the queue.

The given generator should yield strings to send to the process.
`iter-yield' calls return once some response has been received
from the process or after too long has passed without response.
In the latter case, `iter-yield' returns \\='timeout.

If the queue is empty, this function also kicks things off by
sending the first string generated by GEN to the process.

If the queue is not empty, GEN is appended to the current
generator, to be executed afterwards.

Does nothing if GEN is nil."
  (cond
   ((and mistty--queue gen)
    (setq mistty--queue (mistty--iter-chain mistty--queue gen)))
   (gen
    ;; This is the first generator; kick things off.
    (setq mistty--queue gen)
    (mistty--dequeue proc))))

(iter-defun mistty--iter-single (elt)
  "Returns a generator that returns ELT and ends."
  (iter-yield elt))

(iter-defun mistty--iter-chain (iter1 iter2)
  "Returns a generator that first calls ITER1, then ITER2."
  (iter-do (value iter1)
    (iter-yield value))
  (iter-do (value iter2)
    (iter-yield value)))

(provide 'mistty-queue)
